{"version":3,"sources":["worker.js"],"names":["sheet","errs","vals","self","onmessage","data","coord","map","p","toLowerCase","c","name","Object","getOwnPropertyDescriptor","get","defineProperty","NaN","x","toString","eval","call","slice","e","match","exec","postMessage"],"mappings":";AACA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GADA,IAAIA,EAAOC,EAAMC,EACjBC,KAAKC,UAAY,SAAc,GAAXC,IAAAA,EAAAA,EAAAA,KACjBL,EAAsBK,EAAfJ,EAAqB,GAAfC,EAAmB,GAEtBI,IAAAA,EAAAA,SAAAA,GAER,CAAA,GAAI,KAAKC,IAAI,SAAAC,GACZ,MAAA,CAACF,EAAOA,EAAMG,eAAeF,IAAI,SAAAG,GACzBC,IAAAA,EAAOH,EAAIE,GAGZE,OAAOC,yBAAyBV,KAAMQ,IAAS,IAAIG,KAKxDF,OAAOG,eAAeZ,KAAMQ,EAAM,CAChCG,IAAM,WACAR,GAAAA,KAASJ,EACJA,OAAAA,EAAKI,GAEdJ,EAAKI,GAASU,IAGVC,IAAAA,GAAKjB,EAAMM,GACXN,EAAMM,KAAWW,EAAEC,aACrBD,EAAIjB,EAAMM,IAIR,IACFJ,EAAKI,GAAS,MAAQW,EAAE,GAAKE,KAAKC,KAAK,KAAMH,EAAEI,MAAM,IAAMJ,EAC3D,MAAOK,GACDC,IAAAA,EAAQ,4BAA4BC,KAAKF,GAC3CC,GAAAA,KAAWA,EAAM,KAAMpB,MAIlBA,OAFPA,KAAKoB,EAAM,IAAM,SACVrB,EAAKI,GACLH,KAAKG,GAGdL,EAAKK,GAASgB,EAAEJ,WAIHhB,OAAAA,EAAAA,EAAKI,KACb,IAAA,WACA,IAAA,SACHJ,EAAKI,IAAU,GAEZJ,OAAAA,EAAKI,WA9CjB,IAAA,IAAMA,KAASN,EAATM,EAAAA,GAsDN,IAAA,IAAMA,KAASN,EAClBG,KAAKG,GAEPmB,YAAY,CAACxB,EAAMC","file":"worker.6202ec17.map","sourceRoot":"..","sourcesContent":["let sheet, errs, vals;\nself.onmessage = ({ data }) => {\n  [sheet, errs, vals] = [data, {}, {}];\n\n  for (const coord in sheet) {\n    // Four variable names pointing to the same coordinate: A1, a1, $A1, $a1\n    [\"\", \"$\"].map(p =>\n      [coord, coord.toLowerCase()].map(c => {\n        const name = p + c;\n\n        // Worker is reused across computations, so only define each variable once\n        if ((Object.getOwnPropertyDescriptor(self, name) || {}).get) {\n          return;\n        }\n\n        // Define self['A1'], w`hich is the same thing as the global variable A1\n        Object.defineProperty(self, name, {\n          get() {\n            if (coord in vals) {\n              return vals[coord];\n            }\n            vals[coord] = NaN;\n\n            // Turn numeric strings into numbers, so =A1+C1 works when both are numbers\n            let x = +sheet[coord];\n            if (sheet[coord] !== x.toString()) {\n              x = sheet[coord];\n            }\n\n            // Evaluate formula cells that begin with =\n            try {\n              vals[coord] = \"=\" === x[0] ? eval.call(null, x.slice(1)) : x;\n            } catch (e) {\n              const match = /\\$?[A-Za-z]+[1-9][0-9]*\\b/.exec(e);\n              if (match && !(match[0] in self)) {\n                // The formula refers to a uninitialized cell; set it to 0 and retry\n                self[match[0]] = 0;\n                delete vals[coord];\n                return self[coord];\n              }\n              // Otherwise, stringify the caught exception in the errs object\n              errs[coord] = e.toString();\n            }\n\n            // Turn vals[coord] into a string if it's not a number or boolean\n            switch (typeof vals[coord]) {\n              case \"function\":\n              case \"object\":\n                vals[coord] += \"\";\n            }\n            return vals[coord];\n          }\n        });\n      })\n    );\n  }\n\n  // For each coordinate in the sheet, call the property getter defined above\n  for (const coord in sheet) {\n    self[coord];\n  }\n  postMessage([errs, vals]);\n};\n"]}